<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Voxel World - Damian Kita</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky blue */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Wa偶ne dla mobile - blokuje zoom/scroll */
            user-select: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path d="M10 0v20M0 10h20" stroke="white" stroke-width="2"/></svg>');
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            opacity: 0.8;
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            color: white;
            text-align: center;
        }

        #instructions {
            font-size: 24px;
            cursor: pointer;
            padding: 20px;
            border: 2px solid white;
            border-radius: 10px;
            background: rgba(0,0,0,0.5);
            transition: background 0.3s;
        }
        #instructions:hover { background: rgba(0,0,0,0.8); }

        #author-credits {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: auto;
            z-index: 20;
        }
        #author-credits a { color: #4db8ff; text-decoration: none; }

        #mobile-controls {
            display: none; /* Domylnie ukryte, wczane przez JS na mobile */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
        }

        /* Przyciski mobilne */
        .control-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: auto;
            backdrop-filter: blur(4px);
        }
        .control-btn:active { background: rgba(255, 255, 255, 0.5); }

        /* Joystick area lewa strona */
        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0,0,0,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            pointer-events: auto;
        }
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.8);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Przyciski akcji prawa strona */
        #btn-jump { bottom: 60px; right: 40px; width: 60px; height: 60px; border-radius: 50%; background: rgba(0,255,0,0.3); }
        #btn-jump::after { content: ''; position: absolute; top: 15px; left: 20px; color: white; font-size: 24px; }
        
        #btn-place { bottom: 140px; right: 40px; width: 50px; height: 50px; background: rgba(0,0,255,0.3); border-radius: 10px; }
        #btn-place::after { content: '+'; position: absolute; top: 10px; left: 17px; color: white; font-size: 24px; }

        #btn-break { bottom: 140px; right: 110px; width: 50px; height: 50px; background: rgba(255,0,0,0.3); border-radius: 10px; }
        #btn-break::after { content: '-'; position: absolute; top: 8px; left: 19px; color: white; font-size: 24px; }

        /* Slot bar (inventory placeholder) */
        #toolbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 5px;
            pointer-events: auto;
        }
        .slot {
            width: 30px;
            height: 30px;
            border: 2px solid #888;
            background-color: #555;
            cursor: pointer;
        }
        .slot.active { border-color: white; transform: scale(1.1); }
        .slot[data-type="grass"] { background: #5a9e38; }
        .slot[data-type="dirt"] { background: #6d4c34; }
        .slot[data-type="stone"] { background: #7a7a7a; }
        .slot[data-type="wood"] { background: #8B4513; }

    </style>
    <!-- Pobranie Three.js z CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="crosshair"></div>

    <div id="author-credits">
        Autor: Damian Kita<br>
        <a href="https://linktr.ee/kitadamian" target="_blank">https://linktr.ee/kitadamian</a>
    </div>

    <div id="toolbar">
        <div class="slot active" data-type="grass"></div>
        <div class="slot" data-type="dirt"></div>
        <div class="slot" data-type="stone"></div>
        <div class="slot" data-type="wood"></div>
    </div>

    <div id="blocker">
        <div id="instructions">
            <span style="font-size: 36px">Witaj w Voxel World</span><br><br>
            <strong>PC:</strong> Kliknij, aby zagra<br>
            (W, A, S, D = Ruch, SPACJA = Skok, MYSZ = Rozgldanie)<br>
            (LPM = Niszcz, PPM = Buduj)<br><br>
            <strong>MOBILE:</strong> Dotknij ekranu<br>
            (Lewy Joystick = Ruch, Prawa strona = Rozgldanie)<br>
            (Przyciski = Skok/Buduj/Niszcz)
        </div>
    </div>

    <!-- Interfejs mobilny -->
    <div id="mobile-controls">
        <div id="joystick-zone">
            <div id="joystick-knob"></div>
        </div>
        <div class="control-btn" id="btn-jump"></div>
        <div class="control-btn" id="btn-place"></div>
        <div class="control-btn" id="btn-break"></div>
    </div>

<script>
    // --- KONFIGURACJA I ZMIENNE GLOBALNE ---
    let camera, scene, renderer;
    let controlsEnabled = false;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let canJump = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();
    
    // Obiekty gry
    const objects = []; // Bloki, kt贸re mo偶na zniszczy/kolidowa
    let raycaster;
    let selectedBlockType = 'grass';
    
    // Mobile Control State
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    let touchLookStartX = 0, touchLookStartY = 0;
    let touchLookPrevX = 0, touchLookPrevY = 0;
    let joystickActive = false;
    let joystickId = null;
    let joystickOrigin = { x: 0, y: 0 };
    let joystickVector = { x: 0, y: 0 }; // Zakres -1 do 1

    // --- SYSTEM AUDIO (PROCEDURALNY) ---
    const AudioSys = {
        ctx: null,
        bgmOscillators: [],
        gainNode: null,
        isPlaying: false,

        init: function() {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.gainNode = this.ctx.createGain();
            this.gainNode.gain.value = 0.1; // Cicha muzyka
            this.gainNode.connect(this.ctx.destination);
        },

        startMusic: function() {
            if (!this.ctx) this.init();
            if (this.isPlaying) return;
            this.isPlaying = true;
            this.playChord();
            setInterval(() => this.playChord(), 4000); // Nowy akord co 4 sekundy
        },

        playChord: function() {
            // Proste ambientowe akordy
            const frequencies = [
                [261.63, 329.63, 392.00], // C Major
                [220.00, 261.63, 329.63], // A Minor
                [349.23, 440.00, 523.25], // F Major
                [392.00, 493.88, 587.33]  // G Major
            ];
            const chord = frequencies[Math.floor(Math.random() * frequencies.length)];
            
            chord.forEach(freq => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + 1);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);

                osc.connect(gain);
                gain.connect(this.gainNode);
                
                osc.start();
                osc.stop(this.ctx.currentTime + 4);
            });
        },

        playSound: function(type) {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            if (type === 'break') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            } else if (type === 'place') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            }

            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        }
    };

    // --- GENEROWANIE TEKSTUR ---
    function createTexture(colorStr) {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // Base color
        ctx.fillStyle = colorStr;
        ctx.fillRect(0,0,64,64);

        // Noise
        for(let i=0; i<400; i++) {
            ctx.fillStyle = `rgba(0,0,0, ${Math.random() * 0.15})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
            ctx.fillStyle = `rgba(255,255,255, ${Math.random() * 0.1})`;
            ctx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
        }
        
        // Border
        ctx.strokeStyle = "rgba(0,0,0,0.1)";
        ctx.lineWidth = 2;
        ctx.strokeRect(0,0,64,64);

        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter; // Minecraft-style pixelation
        return tex;
    }

    const textures = {
        grass: createTexture('#5a9e38'),
        dirt: createTexture('#6d4c34'),
        stone: createTexture('#7a7a7a'),
        wood: createTexture('#8B4513')
    };

    const materials = {
        grass: new THREE.MeshLambertMaterial({ map: textures.grass }),
        dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
        stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
        wood: new THREE.MeshLambertMaterial({ map: textures.wood }),
        cursor: new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, opacity: 0.5, transparent: true })
    };

    // --- INICJALIZACJA ---
    function init() {
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        // wiato
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // PointerLock (PC Control)
        if (!isMobile) {
            instructions.addEventListener('click', function () {
                document.body.requestPointerLock();
                AudioSys.startMusic();
            });

            document.addEventListener('pointerlockchange', function () {
                if (document.pointerLockElement === document.body) {
                    controlsEnabled = true;
                    blocker.style.display = 'none';
                } else {
                    controlsEnabled = false;
                    blocker.style.display = 'flex';
                }
            });
        } else {
            // Mobile start
            document.getElementById('mobile-controls').style.display = 'block';
            instructions.innerHTML = "Dotknij, aby rozpocz gr!<br><small>Autor: Damian Kita</small>";
            instructions.addEventListener('click', function() {
                controlsEnabled = true;
                blocker.style.display = 'none';
                AudioSys.startMusic();
                // Fullscreen
                if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
            });
        }

        // --- TWORZENIE WIATA ---
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        
        // Generowanie podogi
        const floorSize = 20;
        for (let x = -floorSize; x < floorSize; x++) {
            for (let z = -floorSize; z < floorSize; z++) {
                // Base layer
                createBlock(x, 0, z, 'stone');
                // Top layer
                createBlock(x, 1, z, 'grass');
                
                // Losowe drzewa
                if (Math.random() > 0.98 && x > -15 && x < 15) {
                    createTree(x, 2, z);
                }
            }
        }

        raycaster = new THREE.Raycaster();

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize);
        
        // Listenery klawiatury (PC)
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        // Mysz (PC)
        document.addEventListener('mousedown', onMouseClick);
        document.addEventListener('mousemove', onMouseMovePC);

        // UI Toolbar
        document.querySelectorAll('.slot').forEach(slot => {
            slot.addEventListener('click', (e) => {
                document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                e.target.classList.add('active');
                selectedBlockType = e.target.dataset.type;
            });
            // Touch support for toolbar
            slot.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Stop mouse emulation
                document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                e.target.classList.add('active');
                selectedBlockType = e.target.dataset.type;
            });
        });

        // Setup Mobile Inputs
        if (isMobile) setupMobileControls();

        // Ustaw gracza
        camera.position.y = 5;
    }

    function createBlock(x, y, z, type) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const mesh = new THREE.Mesh(geometry, materials[type]);
        mesh.position.set(x, y, z);
        mesh.name = "block";
        mesh.userData.type = type;
        scene.add(mesh);
        objects.push(mesh);
        return mesh;
    }

    function createTree(x, y, z) {
        // Pieniek
        createBlock(x, y, z, 'wood');
        createBlock(x, y+1, z, 'wood');
        createBlock(x, y+2, z, 'wood');
        // Licie (jako zielona trawa dla uproszczenia)
        createBlock(x, y+3, z, 'grass');
        createBlock(x+1, y+2, z, 'grass');
        createBlock(x-1, y+2, z, 'grass');
        createBlock(x, y+2, z+1, 'grass');
        createBlock(x, y+2, z-1, 'grass');
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- STEROWANIE ---

    function onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveForward = true; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
            case 'ArrowDown': case 'KeyS': moveBackward = true; break;
            case 'ArrowRight': case 'KeyD': moveRight = true; break;
            case 'Space': 
                if (canJump === true) velocity.y += 15; // Jump force
                canJump = false;
                break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveForward = false; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
            case 'ArrowDown': case 'KeyS': moveBackward = false; break;
            case 'ArrowRight': case 'KeyD': moveRight = false; break;
        }
    }

    function onMouseMovePC(event) {
        if (controlsEnabled && !isMobile) {
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            // Obr贸t kamery (Yaw - lewo/prawo)
            camera.rotation.y -= movementX * 0.002;
            
            // Obr贸t kamery (Pitch - g贸ra/d贸) - bezporednia manipulacja X
            camera.rotation.x -= movementY * 0.002;
            // Ograniczenie g贸ra d贸
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            
            // Wa偶ne dla poprawnego obrotu w Three.js bez PointerLockControls class
            camera.rotation.order = "YXZ"; 
        }
    }

    function onMouseClick(event) {
        if (!controlsEnabled) return;
        
        // 0 = Lewy (niszcz), 2 = Prawy (buduj)
        // Raycast
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        const intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {
            const intersect = intersects[0];
            
            if (event.button === 0) { // Niszcz
                scene.remove(intersect.object);
                objects.splice(objects.indexOf(intersect.object), 1);
                AudioSys.playSound('break');
            } 
            else if (event.button === 2) { // Buduj
                const voxel = createBlock(0,0,0, selectedBlockType);
                voxel.position.copy(intersect.point).add(intersect.face.normal);
                voxel.position.divideScalar(1).floor().multiplyScalar(1).addScalar(0.5); // Snap to grid
                // Sprawd藕 czy nie budujemy w graczu
                const dx = Math.abs(camera.position.x - voxel.position.x);
                const dy = Math.abs(camera.position.y - voxel.position.y);
                const dz = Math.abs(camera.position.z - voxel.position.z);
                
                if (dx < 0.8 && dz < 0.8 && dy < 1.8) {
                    scene.remove(voxel);
                    objects.pop();
                } else {
                    AudioSys.playSound('place');
                }
            }
        }
    }

    // --- LOGIKA DOTYKOWA (MOBILE) ---
    function setupMobileControls() {
        const joystickZone = document.getElementById('joystick-zone');
        const joystickKnob = document.getElementById('joystick-knob');
        
        // Joystick
        joystickZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joystickId = touch.identifier;
            joystickActive = true;
            joystickOrigin = { x: touch.clientX, y: touch.clientY };
            joystickKnob.style.transition = 'none';
        }, {passive: false});

        joystickZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joystickActive) return;
            
            // Znajd藕 waciwy dotyk
            for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joystickId) {
                    const touch = e.changedTouches[i];
                    const dx = touch.clientX - joystickOrigin.x;
                    const dy = touch.clientY - joystickOrigin.y;
                    
                    const distance = Math.min(Math.sqrt(dx*dx + dy*dy), 40); // Max promie
                    const angle = Math.atan2(dy, dx);
                    
                    const moveX = Math.cos(angle) * distance;
                    const moveY = Math.sin(angle) * distance;
                    
                    joystickKnob.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
                    
                    // Normalizacja wektora (-1 do 1)
                    joystickVector.x = moveX / 40; // Prawo/Lewo
                    joystickVector.y = moveY / 40; // Prz贸d/Ty (negatywne Y to g贸ra ekranu, czyli prz贸d)
                }
            }
        }, {passive: false});

        const endJoystick = (e) => {
            joystickActive = false;
            joystickVector = { x: 0, y: 0 };
            joystickKnob.style.transition = '0.2s';
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        };
        joystickZone.addEventListener('touchend', endJoystick);
        joystickZone.addEventListener('touchcancel', endJoystick);

        // Rozgldanie si (prawa strona ekranu, poza przyciskami)
        document.addEventListener('touchstart', (e) => {
            if (!controlsEnabled) return;
            // Ignoruj jeli dotyk na joysticku lub UI
            if (e.target.closest('#mobile-controls') || e.target.closest('#toolbar')) return;

            const touch = e.changedTouches[0];
            if (touch.clientX > window.innerWidth / 2) {
                touchLookStartX = touch.clientX;
                touchLookStartY = touch.clientY;
                touchLookPrevX = touch.clientX;
                touchLookPrevY = touch.clientY;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (!controlsEnabled) return;
            if (e.target.closest('#mobile-controls') || e.target.closest('#toolbar')) return;

            const touch = e.changedTouches[0];
            if (touch.clientX > window.innerWidth / 2) {
                const deltaX = touch.clientX - touchLookPrevX;
                const deltaY = touch.clientY - touchLookPrevY;

                camera.rotation.y -= deltaX * 0.005;
                camera.rotation.x -= deltaY * 0.005;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                camera.rotation.order = "YXZ";

                touchLookPrevX = touch.clientX;
                touchLookPrevY = touch.clientY;
            }
        }, {passive: false});

        // Przyciski akcji
        document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (canJump) { velocity.y += 15; canJump = false; }
        });

        document.getElementById('btn-break').addEventListener('touchstart', (e) => {
            e.preventDefault();
            onMouseClick({ button: 0 }); // Symuluj lewy klik
        });

        document.getElementById('btn-place').addEventListener('touchstart', (e) => {
            e.preventDefault();
            onMouseClick({ button: 2 }); // Symuluj prawy klik
        });
    }

    // --- PTLA GRY ---

    function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        const delta = (time - prevTime) / 1000;

        if (controlsEnabled) {
            // Fizyka
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 30.0 * delta; // Grawitacja (9.8 * ~3 for game feel)

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize(); // Ensure consistent speed in all directions

            // Mobile input injection
            if (isMobile && joystickActive) {
                direction.z = -joystickVector.y; // Joystick Up is negative Y screen
                direction.x = joystickVector.x;
            }

            if (moveForward || moveBackward || (isMobile && joystickActive)) velocity.z -= direction.z * 400.0 * delta;
            if (moveLeft || moveRight || (isMobile && joystickActive)) velocity.x -= direction.x * 400.0 * delta;

            // Ruch boczny (Strafe) i prz贸d ty wzgldem kamery
            // velocity jest w local space? Nie, PointerLockControls u偶ywa local. My musimy przeliczy.
            // Uproszczona fizyka: przesu kamer zgodnie z velocity, ale uwzgldnij obr贸t "Y" kamery.
            
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);

            // Oblicz realny wektor przesunicia na podstawie inputu i kta kamery
            // To podejcie jest stabilniejsze ni偶 modyfikacja velocity w world space bezporednio z klawiszy
            
            // Reset ruchu X/Z dla czystego obliczenia
            let moveVec = new THREE.Vector3();
            if (moveForward) moveVec.add(forward);
            if (moveBackward) moveVec.sub(forward);
            if (moveRight) moveVec.add(right);
            if (moveLeft) moveVec.sub(right);
            
            if (isMobile && joystickActive) {
                // Joystick forward/back
                let joyFwd = forward.clone().multiplyScalar(-joystickVector.y);
                let joyRight = right.clone().multiplyScalar(joystickVector.x);
                moveVec.add(joyFwd).add(joyRight);
            }

            moveVec.normalize().multiplyScalar(10 * delta); // Speed

            camera.position.add(moveVec);
            camera.position.y += velocity.y * delta; // Vertical move

            // Kolizja z podog (prosta - wysoko blok贸w to 1.0, 2.0 itd)
            // Raycast w d贸
            raycaster.set(camera.position, new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObjects(objects);
            
            // Player height = 1.6
            if (intersects.length > 0 && intersects[0].distance < 1.6) {
                velocity.y = Math.max(0, velocity.y);
                camera.position.y = intersects[0].point.y + 1.6;
                canJump = true;
            }

            // Fallback (偶eby nie spa w nieskoczono poza map)
            if (camera.position.y < -10) {
                velocity.y = 0;
                camera.position.y = 10;
                camera.position.x = 0;
                camera.position.z = 0;
            }
        }

        prevTime = time;
        renderer.render(scene, camera);
    }

    init();
    animate();

</script>
</body>
</html>